<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.0.3/leaflet.js"></script>
    <script src="https://maps.api.sygic.com/js/leaflet.sygic-1.1.0.js"></script>
    <script src="https://code.jquery.com/jquery-2.2.4.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44="
        crossorigin="anonymous"></script>
    <script src="numbered-icon.js"></script>
</head>

<body>
    <div id="map">
    </div>
</body>
<script src="Polyline.encoded.js"></script>
<script type="text/javascript">

    //get apikey from URL to be used in sygic api calls
    var getApiKey = function () {
        var search = window.location.search.substr(1).split("=");
        if (search[0] == "key" && search[1]) {
            return search[1];
        } else {
            alert("You have to provide api-key in the URL https://sygic.github.io/?key=YOUR_API_KEY");
        }
    }
    var apiKey = getApiKey();

    var optimizationUrl = "https://optimization.api.sygic.com/v0/api/optimization?key=" + apiKey;
    var routingUrl = "https://directions.api.sygic.com/v0/api/directions?key=" + apiKey;

    var map = L.map("map");

    var sygicTileLayer = L.TileLayer.sygic(apiKey);
    L.layerGroup([sygicTileLayer]).addTo(map);

    //we start in one depot, want to deliver to three different locations and then finish in another depot
    var problemDescription = {
        startDepot: "52.93719,9.51316", //we start and end in same location
        endDepot: "52.93994,9.52276",
        waypointsToBeOptimized: ["52.90807,9.49030", "52.92994,9.51154", "52.92520,9.51922"]
    }

    var optimizationApiInput = {
        locations: [
            {
                location_id: "start",
                coordinates: problemDescription.startDepot
            },
            {
                location_id: "waypoint-0",
                coordinates: problemDescription.waypointsToBeOptimized[0]
            },
            {
                location_id: "waypoint-1",
                coordinates: problemDescription.waypointsToBeOptimized[1]
            },
            {
                location_id: "waypoint-2",
                coordinates: problemDescription.waypointsToBeOptimized[2]
            },
            {
                location_id: "end",
                coordinates: problemDescription.endDepot
            }
        ],
        tasks: [
            {
                task_id: "task-to-waypoint-0",
                priority: "critical", //we don't want to skip this at any cost
                activities: [
                    {
                        activity_type: "Visit",
                        location_id: "waypoint-0"
                    }
                ]
            },
            {
                task_id: "task-to-waypoint-1",
                priority: "critical",
                activities: [
                    {
                        activity_type: "Visit",
                        location_id: "waypoint-1"
                    }
                ]
            },
            {
                task_id: "task-to-waypoint-2",
                priority: "critical",
                activities: [
                    {
                        activity_type: "Visit",
                        location_id: "waypoint-2"
                    }
                ]
            }
        ],
        vehicles: [
            {
                vehicle_id: "vehicle",
                profile: "Car",
                start_location_id: "start",
                end_location_id: "end"
            }
        ]
    }


    if (apiKey) {
        optimize(optimizationApiInput);
    }

    // post request for optimization
    function optimize(data) {
        $.ajax({
            type: 'POST',
            url: optimizationUrl,
            dataType: 'json',
            contentType: "application/json; charset=UTF-8",
            data: JSON.stringify(data),
        }).done(function (data, textStatus, xhr) {
            // get url for result of optimization
            var location = xhr.getResponseHeader("location");
            getResults(location);
        }).fail(function (data, textStatus, xhr) {
            alert("FAILED!\r\n" + JSON.stringify(data, null, 2));
        });
    };

    // get result of optimization
    function getResults(url) {
        $.ajax({
            type: "GET",
            url: url,
            dataType: "json",
            contentType: "application/json; charset=UTF-8",
        }).done(function (data, textStatus, xhr) {
            // check state of optimization process 
            if (isWaitingForResults(data.state)) {
                setTimeout(function () { getResults(url); }, 1000);
            } else {
                displayOptimizationResults(data);
            }
        }).fail(function (data, textStatus, xhr) {
            alert("FAILED!\r\n" + JSON.stringify(data, null, 2));
        });
    };

    function isWaitingForResults(state) {
        return state === "Waiting" || state === "Running";
    }

    // process results of optimization, display data on map
    function displayOptimizationResults(data) {
        var bounds = L.latLngBounds();
        var locations = {};

        if (data.state === "Failed") {
            alert("FAILED!\r\n" + JSON.stringify(data, null, 2))
        } else {

            // create assoc. array of locations by ids for marker creation 
            data.locations.forEach(function (l) {
                locations[l.location_id] = l.coordinates.split(',');
            });

            // parse plans of tour
            data.plan.forEach(function (plan, vehicleIndex) {

                var markerLayer = L.layerGroup();

                var originCoordinates = locations[plan.activities[0].location_id];
                var destinationCoordinates = locations[plan.activities[plan.activities.length - 1].location_id];
                var waypointsCoordinates = [];

                // parse activities from current plan
                plan.activities.forEach(function (activity, activityIndex) {
                    var coordinates = locations[activity.location_id];
                    console.log(activity.location_id)
                    bounds.extend(coordinates);

                    if (activityIndex === 0 || activityIndex === plan.activities.length - 1) {
                        var origin = createMarker(coordinates, "black", "DEPOT " + activity.location_id);
                        markerLayer.addLayer(origin);
                    } else {
                        var point = createMarker(coordinates, "blue", "visit #" + activityIndex + "</br>" + activity.location_id);
                        waypointsCoordinates.push(coordinates.join(','));
                        markerLayer.addLayer(point);
                    }
                });

                markerLayer.addTo(map);

                var routingApiInputData = {
                    origin: originCoordinates.join(','),
                    destination: destinationCoordinates.join(','),
                    waypoints: waypointsCoordinates.join('|')
                }

                getRoute(routingApiInputData);
            });

            // fit map to all markers
            map.fitBounds(bounds);
        }

        function getRoute(data) {
            $.ajax({
                type: "POST",
                url: routingUrl,
                dataType: "json",
                contentType: "application/json; charset=UTF-8",
                data: JSON.stringify(data),
            }).done(function (data, textStatus, xhr) {
                parseRoutingResponse(data);
            }).fail(function (data, textStatus, xhr) {
                alert("FAILED!\r\n" + JSON.stringify(data, null, 2));
            });
        }

        function createMarker(coordinates, color, index) {
            var icon = new L.NumberedDivIcon({ number: index, iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-' + color + '.png', });
            var marker = new L.marker(coordinates, {
                icon: icon
            });
            return marker;
        }

        // parse routing response and show route on map
        function parseRoutingResponse(data) {
            var encodedPolylineString = data.routes[0].route;
            if (typeof (encodedPolylineString) === 'undefined') return;
            var polyline = L.Polyline.fromEncoded(encodedPolylineString, {
                color: "red",
                weight: 3,
                smoothFactor: 1
            });

            polyline.addTo(map);
        }
    }
</script>

</html>